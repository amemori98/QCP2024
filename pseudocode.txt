I made it very non technical to kinda see the structure, feel free to make it more technical or even start making it. The State class is already started.

checklist and things to implement (Jordi):
    Shors
    documentation on existing classes(WIP)
    X add T and S gates
    x add adjoint methods for matrices
    work on shors part of report and performance testing
    need to combine all code in 1 file

class lazy:  \\not entirely sure how this would tie in with the rest
	makes a function lazy  \\maybe not needed, sparse matrix class might already be lazy
	https://stackoverflow.com/questions/7151890/python-lazy-variables-or-delayed-expensive-computation

class sparse_matrix:  
\\array of non-zero diagonals to represent the matrix, the longest non-zero diagonal would be the main diagonal and the position of the other diagonals could be 
	

# pseudocode Elena

class Quantum State:

Functions:
- Initializer: no_of_qubits, state

(gates)
- Hadamard, phase shift, c-NOT (forms a universal set of gates), could also do (H + c-V)

(tensor products)
- Qubit tensor product, matrix vector product

(circuit model - apply gates to quantum register which is the tensor product of qubits)

need to also implement grover's algorithm (searches a superposition of 2^n states + produces a state close to one flipped by oracle - a reflection in direction of unknown state phi, oracle is the gate R_phi = 1 - 2*projection of phi)




\\ pseudocode for grovers algorithm 

function grovers_algorithm(num_qubits, ...)
  initialise qubits - create a superposition of all states 's'
  s = state from applying hadamard to all qubits
   
  repeat until reach target w:
    reflect about s' axis (oracle circuit)
    
    reflect about s axis (diffusion operator)
  end repeat
  
  measure final state
  
  show visualisation:
    print initial state (as bloch spheres?)
    print final state 
    

function oracle_circuit:

function diffusion_operator:
